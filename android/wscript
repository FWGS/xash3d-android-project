#!/usr/bin/env python
# encoding: utf-8
# a1batross, 2019
import os

def options(opt):
	# opt.load('java')
	print('opt android')
	opt.load('android')
	return

def configure(conf):
	conf.load('android')
	conf.env.D8_DEBUG = conf.options.BUILD_TYPE != 'release'
	conf.find_program('objcopy')
	# conf.load('java')
	return

from waflib import TaskGen, Task, Build

# HACK: collect all our libraries and modify jni task
libs = []
tgens = []
jnifiles = {}

class strip_task(Task.Task):
	run_str = '${OBJCOPY} -g ${SRC[0].abspath()} ${TGT[0].abspath()}'
	def keyworf(self):
		return 'Stripping'

def build(bld):
	jni_dir = bld.root.get_bld().parent.make_node('lib')
	arch_dir = jni_dir.make_node("arm64-v8a")
	tsk = bld(features = 'android javac',
		srcdir = 'src',
		compat = '1.6',
		name = 'xashdroid',
		keystore = bld.path.parent.find_node('debug.keystore'),
		debug = bld.env.D8_DEBUG,
		target_api = 29)
	tsk.env.append_unique('JAVACFLAGS', ['-target', '1.6'])
	
	@TaskGen.feature('cshlib','cxxshlib')
	@TaskGen.after_method('apply_android_soname')
	def copy_lib(self):
		lib = self.link_task.outputs[0]
		strip_output = lib.parent.make_node('lib' + self.name + '.stripped.so')
		self.strip_task = self.create_task('strip_task', lib, strip_output)
#		link_task =  self.link_task
		link_task = self.strip_task
		lib = strip_output
		libs.append(lib)
		tgens.append(self.name)
		jnifiles[lib] = self.install_path + '/lib' + self.name + '.so'
		# print('APPLY_LINK',lib)
#		self.bld.get_tgen_by_name(self.name).post()

		@TaskGen.feature('android')
		@TaskGen.after_method('apply_d8')
		def pack_native_library(self):
			# print('APPLY_D8', libs, jnifiles)
			self.apkjni_task.set_run_after(self.d8_task)
			self.apkdex_task.set_run_after(self.apkjni_task)
			
			self.apkjni_task.inputs += libs
			self.apkjni_task.jnifiles.update(jnifiles)
			libs.clear()

	# force post all shlibs after processing decorators to make all nodes registered
	if not bld.targets:
		for t in tgens:
			bld.get_tgen_by_name(t).post()
		tsk.post()

