#!/usr/bin/env python
# encoding: utf-8
# a1batross, 2019
import os

def options(opt):
	# opt.load('java')
	print('opt android')
	opt.load('android')
	return

def configure(conf):
	conf.load('android', os.path.join(str(conf.path), '../scripts/waifulib'))
	conf.env.D8_DEBUG = conf.options.BUILD_TYPE != 'release'
	# conf.load('java')
	return

from waflib import Task

class copylibs(Task.Task):
	color = 'GREEN'
	run_str = '${CP} ${SRC} ${TGT}'
	ext_in  = ['.so']

from waflib import TaskGen, Task, Build

# HACK: collect all our libraries and modify jni task
libs = []
tgens = []
jnifiles = {}

def build(bld):
	jni_dir = bld.root.get_bld().parent.make_node('lib')
	arch_dir = jni_dir.make_node("arm64-v8a")
	tsk = bld(features = 'android javac',
		srcdir = 'src',
		compat = '1.6',
		name = 'xashdroid',
		keystore = bld.path.parent.find_node('debug.keystore'),
		debug = bld.env.D8_DEBUG,
		target_api = 29)
	tsk.env.append_unique('JAVACFLAGS', ['-target', '1.6'])
	
	@TaskGen.feature('cshlib','cxxshlib')
	@TaskGen.after_method('apply_android_soname')
	def copy_lib(self):
		lib = self.link_task.outputs[0]
		link_task =  self.link_task
		libs.append(lib)
		tgens.append(self.name)
		jnifiles[lib] = self.install_path + '/lib' + self.name + '.so'
		# print('APPLY_LINK',lib)
#		self.bld.get_tgen_by_name(self.name).post()

		@TaskGen.feature('android')
		@TaskGen.after_method('apply_d8')
		def pack_native_library(self):
			# print('APPLY_D8', libs, jnifiles)
			self.apkjni_task.set_run_after(self.d8_task)
			self.apkdex_task.set_run_after(self.apkjni_task)
			
			self.apkjni_task.inputs += libs
			self.apkjni_task.jnifiles.update(jnifiles)
			libs.clear()

	# force post all shlibs after processing decorators to make all nodes registered
	for t in tgens:
		bld.get_tgen_by_name(t).post()
	tsk.post()

